pragma language_version >= 0.20;

// FaucetAMM contract using SHIELDED tokens (mintShieldedToken)
// Combines a Faucet and an AMM for testing purposes

import CompactStandardLibrary;

// Swap fee in basis points (e.g. 10 = 0.1%)
export ledger feeBps: Uint<16>;

// The fee is only charged on the X side
export ledger xRewards: Uint<128>;

// Liquidity tracking
export ledger xLiquidity: Uint<128>;

export ledger yLiquidity: Uint<128>;

export ledger lpCirculatingSupply: Uint<128>;

// Nonce management for shielded token minting
// Each mint needs a unique nonce, managed via Counter + evolveNonce
export ledger mintCounter: Counter;
export ledger mintNonce: Bytes<32>;

// Only initializes the ledger contract state but doesn't yet initialize the liquidity 
constructor(
    f: Uint<16>,
    initialNonce: Bytes<32>
) {
    // Fee must be less than 100% (10000 basis points)
    assert(f < 10000, "Fee too high");

    feeBps = disclose(f);
    xRewards = 0;
    xLiquidity = 0;
    yLiquidity = 0;
    lpCirculatingSupply = 0;
    mintNonce = disclose(initialNonce);
}

// Helper: evolve the nonce and mint a shielded token
circuit doShieldedMint(
    tokenName: Bytes<32>,
    amount: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>
): [] {
    mintCounter.increment(1);
    mintNonce = evolveNonce(mintCounter, mintNonce);
    mintShieldedToken(
        tokenName,
        disclose(amount),
        mintNonce,
        disclose(recipient)
    );
}

// MINT FUNCTIONS - Using SHIELDED tokens
export circuit mintTestTokensX(
    xOut: Uint<64>, 
    recipient: Either<ZswapCoinPublicKey, ContractAddress>
): [] {
    doShieldedMint(getXTokenName(), xOut, recipient);
}

export circuit mintTestTokensY(
    yOut: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>
): [] {
    doShieldedMint(getYTokenName(), yOut, recipient);
}

// LIQUIDITY FUNCTIONS - Using SHIELDED tokens
// receive xIn
// receive yIn
// mint and send lpOut to recipient
export circuit initLiquidity(
    xIn: Uint<64>,
    yIn: Uint<64>,
    lpOut: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>
): [] {
    assert(lpCirculatingSupply == 0, "Already initialized");
    assert(lpOut*lpOut <= xIn*yIn, "Too many LP tokens taken");

    // mint and send lp tokens to recipient (shielded)
    lpCirculatingSupply = disclose(lpOut);
    doShieldedMint(getLPTokenName(), lpOut, recipient);

    // Note: For testing, we don't actually receive tokens (faucet mode)
    // Just update ledger state
    xLiquidity = disclose(xIn);
    yLiquidity = disclose(yIn);
}

// receive xLiquidity + xIn
// receive yLiquidity + yIn
// mint and send lpOut to recipient
export circuit addLiquidity(
    xIn: Uint<64>,
    yIn: Uint<64>,
    lpOut: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>
): [] {
    assert(lpCirculatingSupply > 0, "Not yet initialized");

    const xLiquidityAdded = disclose(xIn);
    const yLiquidityAdded = disclose(yIn);

    if (xLiquidityAdded * yLiquidity < yLiquidityAdded * xLiquidity) {
        const xLhs = lpOut * xLiquidity;
        const xRhs = xLiquidityAdded * lpCirculatingSupply;
        assert(xLhs <= xRhs, "Too many LP tokens taken (bound by xIn)");
    } else {
        const yLhs = lpOut * yLiquidity;
        const yRhs = yLiquidityAdded * lpCirculatingSupply;
        assert(yLhs <= yRhs, "Too many LP tokens taken (bound by yIn)");
    }

    // send lp tokens to recipient (shielded)
    lpCirculatingSupply = lpCirculatingSupply + disclose(lpOut) as Uint<128>;
    doShieldedMint(getLPTokenName(), lpOut, recipient);

    // Update liquidity (faucet mode - no actual receive needed)
    xLiquidity = xLiquidity + xLiquidityAdded as Uint<128>;
    yLiquidity = yLiquidity + yLiquidityAdded as Uint<128>;
}

export circuit removeLiquidity(
    lpIn: Uint<64>,
    xOut: Uint<64>,
    yOut: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>
): [] {
    const xLhs = xOut * lpCirculatingSupply;
    const xRhs = lpIn * xLiquidity;
    assert(xLhs <= xRhs, "Too many X tokens taken");
    
    const yLhs = yOut * lpCirculatingSupply;
    const yRhs = lpIn * yLiquidity;
    assert(yLhs <= yRhs, "Too many Y tokens taken");

    // Update LP supply (faucet mode)
    lpCirculatingSupply = lpCirculatingSupply - disclose(lpIn);

    // send x tokens to recipient (shielded)
    xLiquidity = xLiquidity - disclose(xOut);
    doShieldedMint(getXTokenName(), xOut, recipient);

    // send y tokens to recipient (shielded)
    yLiquidity = yLiquidity - disclose(yOut);
    doShieldedMint(getYTokenName(), yOut, recipient);
}

export circuit swapXToY(
    xIn: Uint<64>,
    xFee: Uint<64>,
    yOut: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>
): [] {
    assert(xFee * 10000 >= xIn * feeBps, "Fee too low");

    const initialK = calcK(xLiquidity, yLiquidity);

    // Update liquidity (faucet mode)
    xRewards = xRewards + disclose(xFee) as Uint<128>;
    xLiquidity = xLiquidity + disclose(xIn - xFee) as Uint<128>;

    // send y tokens to recipient (shielded)
    yLiquidity = yLiquidity - disclose(yOut);
    doShieldedMint(getYTokenName(), yOut, recipient);

    const finalK = calcK(xLiquidity, yLiquidity);

    assert(finalK >= initialK, "Final k smaller than initial k");
}

export circuit swapYToX(
    yIn: Uint<64>,
    xFee: Uint<64>,
    xOut: Uint<64>,
    recipient: Either<ZswapCoinPublicKey, ContractAddress>
): [] {
    assert(xFee * (10000 - feeBps) >= xOut * feeBps, "Fee too low");

    const initialK = calcK(xLiquidity, yLiquidity);

    // send x tokens to recipient (shielded)
    xRewards = xRewards + disclose(xFee) as Uint<128>;
    xLiquidity = xLiquidity - disclose(xOut + xFee);
    doShieldedMint(getXTokenName(), xOut, recipient);

    // Update y liquidity (faucet mode)
    yLiquidity = yLiquidity + disclose(yIn) as Uint<128>;

    const finalK = calcK(xLiquidity, yLiquidity);

    assert(finalK >= initialK, "Final k smaller than initial k");
}

circuit getLPTokenName(): Bytes<32> {
    return pad(32, "Pulse LP Token");
}

circuit getXTokenName(): Bytes<32> {
    return pad(32, "Test token X");
}

circuit getYTokenName(): Bytes<32> {
    return pad(32, "Test token Y");
}

circuit calcK(x: Uint<128>, y: Uint<128>): Uint<248> {
    return ((x as Uint<124>) * (y as Uint<124>)) as Uint<248>;
}
