// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/Uint128.compact)

pragma language_version >= 0.20.0;

/**
 * @title Uint128
 * @dev A utility module providing mathematical operations for 128-bit unsigned integers
 * using the U128 struct, which represents numbers as high * 2^64 + low, where high and low are
 * 64-bit unsigned integers (Uint<64>) in [0, 2^64 - 1]. The module supports conversions,
 * comparisons, arithmetic, division, square root, and utility functions. Operations are provided
 * in dual forms: one for Uint<128> inputs with conversions to/from U128, and another for direct
 * U128 inputs.
 *
 * Supported Mathematical Operations:
 * - Conversions:
 *   - toU128(): Converts a Uint<128> to a U128 struct by splitting into high and low 64-bit parts.
 *   - fromU128(): Converts a U128 struct to a Uint<128> by combining high and low parts.
 * - Comparisons:
 *   - eq(), eqU128(): Checks if two 128-bit numbers are equal.
 *   - lt(), ltU128(): Checks if one 128-bit number is less than another.
 *   - lte(), lteU128(): Checks if one 128-bit number is less than or equal to another.
 *   - gt(), gtU128(): Checks if one 128-bit number is greater than another.
 *   - gte(), gteU128(): Checks if one 128-bit number is greater than or equal to another.
 * - Arithmetic:
 *   - add(), addU128(): Adds two 128-bit numbers, returning a U256 sum.
 *   - addChecked(), addCheckedU128(): Adds two 128-bit numbers, checking for overflow for Uint<128>.
 *   - sub(), subU128(): Subtracts one 128-bit number from another, checking for underflow.
 *   - mul(), mulU128(): Multiplies two 128-bit numbers, returning a U256 product.
 *   - mulChecked(), mulCheckedU128(): Multiplies two 128-bit numbers, checking for overflow for Uint<128>.
 * - Division:
 *   - div(), divU128(): Computes the quotient of dividing one 128-bit number by another.
 *   - rem(), remU128(): Computes the remainder of dividing one 128-bit number by another.
 * - Square Root:
 *   - sqrt(), sqrtU128(): Computes the floor of the square root of a 128-bit number.
 * - Utility:
 *   - min(), minU128(): Returns the smaller of two 128-bit numbers.
 *   - max(), maxU128(): Returns the larger of two 128-bit numbers.
 *   - isMultiple(), isMultipleU128(): Checks if one 128-bit number is a multiple of another.
 */
module Uint128 {
  import { MAX_UINT8, MAX_UINT16, MAX_UINT32, MAX_UINT64 } from Uint64;

  // U128 and U256 types are imported from dedicated type modules to avoid
  // cyclic dependencies between Uint128 and Uint256. See TU128/TU256 documentation.
  import "./types/TU128";
  import "./types/TU256";

  /**
   * @description A struct representing the result of a division operation on U128 values.
   */
  export struct DivResultU128 {
    /**
     * @description The quotient result of the division operation
     */
    quotient: U128,
    /**
     * @description The remainder result of the division operation
     */
    remainder: U128
  }

  /**
   * @description Computes division of two U128 values locally (off-chain).
   *
   * @param a The number to divide.
   * @param b The number to divide by.
   * @returns DivResultU128 The quotient and remainder of the division as U128 values.
   */
  export witness divU128Locally(a: U128, b: U128): DivResultU128;

  /**
   * @description Computes division of two Uint<128> values locally (off-chain).
   *
   * @param a The number to divide.
   * @param b The number to divide by.
   * @returns DivResultU128 The quotient and remainder of the division as U128 values.
   */
  export witness divUint128Locally(a: Uint<128>, b: Uint<128>): DivResultU128;

  /**
   * @description Computes the square root of a U128 value locally (off-chain).
   *
   * @param radicand The U128 value to compute the square root of.
   * @returns Uint<64> The square root of radicand.
   */
  export witness sqrtU128Locally(radicand: U128): Uint<64>;

  /**
   * @title Modulus U128 circuit
   * @description A pure circuit that returns the modulus value of U128 (2^64).
   *
   * @circuitInfo k=10, rows=451
   *
   * @returns {Uint<65>} The value 2^64 (18446744073709551616).
   */
  export pure circuit MODULUS(): Uint<65> {
    // pow() is not supported yet, so we hardcode this value.
    return 18446744073709551616; // 2^64
  }

  /**
   * @title Zero U128 circuit
   * @description A pure circuit that returns a zero U128 struct.
   *
   * @circuitInfo k=10, rows=451
   *
   * @returns {U128} A U128 struct with low and high fields set to 0.
   */
  export pure circuit ZERO_U128(): U128 {
    return U128 { low: 0, high: 0 };
  }

  /**
   * @title MAX_U128 circuit
   * @description Returns the maximum value for a U128 struct, where both low and high
   * fields are set to the maximum 64-bit value (2^64 - 1).
   *
   * @circuitInfo k=10, rows=128
   *
   * @returns {U128} A U128 struct representing 2^128 - 1.
   */
  export pure circuit MAX_U128(): U128 {
    return U128 { low: MAX_UINT64(), high: MAX_UINT64() };
  }

  /**
   * @title MAX_UINT128 circuit
   * @description Returns the maximum value for a 128-bit unsigned integer (2^128 - 1).
   *
   * @circuitInfo k=10, rows=128
   *
   * @returns {Uint<128>} The value 340,282,366,920,938,463,463,374,607,431,768,211,455
   * (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF).
   */
  export pure circuit MAX_UINT128(): Uint<128> {
    return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
  }

  /**
   * @title To U128 circuit
   * @description Converts a Uint<128> to a U128 struct.
   *
   * This circuit converts a 128-bit unsigned integer (`value`) to a U128 struct
   * (`{ low: Uint<64>, high: Uint<64> }`), where `low` holds the lower 64 bits and `high` holds the
   * upper 64 bits of `value`. The conversion is verified to ensure correctness.
   *
   * Theoretical Description:
   * The circuit splits a 128-bit unsigned integer value into two 64-bit unsigned integers,
   * value = high * 2^64 + low, where high, low are in [0, 2^64 - 1]. The result is a U128 struct
   * with low = value mod 2^64 and high = floor(value / 2^64).
   *
   * Mathematical Steps:
   * 1. Propose Low and High Parts:
   *    - Compute low = value mod 2^64, the least significant 64 bits of value.
   *    - Compute high = floor(value / 2^64), the most significant 64 bits of value.
   * 2. Verification:
   *    - Reconstruct reconstructed = high * 2^64 + low, a 128-bit unsigned integer.
   *    - Verify that reconstructed = value to ensure the conversion is correct.
   * 3. Result Construction:
   *    - Return (low, high), a U128 struct satisfying value = high * 2^64 + low.
   *
   * The circuit ensures correctness by verifying the reconstructed value matches the input, using
   * arithmetic operations within the 128-bit domain.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {Uint<128>} value - The Uint<128> value to convert.
   *
   * @returns {U128} A U128 struct with low and high fields representing the lower and upper 64 bits.
   *
   * @throws {Error} "MathU128: conversion invalid" If the reconstructed value does not match the input.
   */
  export circuit toU128(value: Uint<128>): U128 {
    const result = divUint128Locally(value, MODULUS());
    const high = result.quotient.low;
    const low = result.remainder.low;

    // Verify that value = high * 2^64 + low
    const highShifted = (high as Uint<128>) * MODULUS(); // high * 2^64
    const reconstructed = highShifted + (low as Uint<128>); // high * 2^64 + low

    // Verify reconstruction matches value
    assert(reconstructed == value, "MathU128: conversion invalid");

    return U128 { low: low, high: high };
  }

  /**
   * @title From U128 circuit
   * @description Converts a U128 struct to a Uint<128>.
   *
   * This circuit converts a U128 struct ({ low: Uint<64>, high: Uint<64> }) to a 128-bit unsigned
   * integer by reconstructing value = high * 2^64 + low, where high and low are the upper and lower
   * 64 bits respectively.
   *
   * Theoretical Description:
   * The circuit combines two 64-bit unsigned integers (high, low) into a single 128-bit unsigned
   * integer value, where value = high * 2^64 + low. The conversion reconstructs the original value
   * by shifting high left by 64 bits and adding low.
   *
   * Mathematical Steps:
   * 1. Shift High Part:
   *    - Compute highShifted = high * 2^64, shifting high left by 64 bits.
   * 2. Combine Parts:
   *    - Compute result = highShifted + low, combining the shifted high part with low.
   * 3. Result:
   *    - Return result as a Uint<128>, satisfying result = high * 2^64 + low.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} value - The U128 struct to convert.
   *
   * @returns {Uint<128>} The 128-bit value represented by high * 2^64 + low.
   */
  export pure circuit fromU128(value: U128): Uint<128> {
    const highShifted = (value.high as Uint<128>) * MODULUS();
    const result = highShifted + (value.low as Uint<128>);
    return result as Uint<128>;
  }

  /**
   * @title Is Zero circuit
   * @description Checks if a Uint<128> value equals zero.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {Uint<128>} a - The Uint<128> value to check.
   *
   * @returns {Boolean} True if a equals zero, false otherwise.
   */
  export pure circuit isZero(a: Uint<128>): Boolean {
    return a == 0;
  }

  /**
   * @title Is Zero U128 circuit
   * @description Checks if a U128 value equals zero.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} a - The U128 value to check.
   *
   * @returns {Boolean} True if a equals zero (a.low = a.high = 0), false otherwise.
   */
  export pure circuit isZeroU128(a: U128): Boolean {
    return a.low == 0 && a.high == 0;
  }

  /**
   * @title Equality circuit
   * @description Compares two Uint<128> values for equality.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Boolean} True if a is equal than b, false otherwise.
   */
  export pure circuit eq(a: Uint<128>, b: Uint<128>): Boolean {
    return a == b;
  }

  /**
   * @title Equality U128 circuit
   * @description Compares two U128 values for equality.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {Boolean} True if a is equal b, false otherwise.
   */
  export pure circuit eqU128(a: U128, b: U128): Boolean {
    return a.low == b.low && a.high == b.high;
  }

  /**
   * @title Less Than circuit
   * @description Checks if one Uint<128> value is less than another.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Boolean} True if a is less than b, false otherwise.
   */
  export pure circuit lt(a: Uint<128>, b: Uint<128>): Boolean {
    return a < b;
  }

  /**
   * @title Less Than or Equal circuit
   * @description Checks if one Uint<128> value is less than or equal to another.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Boolean}
   */
  export pure circuit lte(a: Uint<128>, b: Uint<128>): Boolean {
    return a <= b;
  }

  /**
   * @title Less Than U128 circuit
   * @description Checks if one U128 value is less than another.
   *
   * @param a The first U128 value.
   * @param b The second U128 value.
   * @returns Boolean True if a is less than b, false otherwise.
   */
  export pure circuit ltU128(a: U128, b: U128): Boolean {
    return a.high < b.high || (a.high == b.high && a.low < b.low);
  }

  /**
   * @title Less Than or Equal U128 circuit
   * @description Checks if one U128 value is less than or equal to another.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {Boolean} True if a is less than or equal to b, false otherwise.
   */
  export pure circuit lteU128(a: U128, b: U128): Boolean {
    return ltU128(a, b) || eqU128(a, b);
  }

  /**
   * @title Greater Than circuit
   * @description Checks if one Uint<128> value is greater than another.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Boolean} True if a is greater than b, false otherwise.
   */
  export pure circuit gt(a: Uint<128>, b: Uint<128>): Boolean {
    return a > b;
  }

  /**
   * @title Greater Than or Equal circuit
   * @description Checks if one Uint<128> value is greater than or equal to another.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Boolean} True if a is greater than or equal to b, false otherwise.
   */
  export pure circuit gte(a: Uint<128>, b: Uint<128>): Boolean {
    return a >= b;
  }

  /**
   * @title Greater Than U128 circuit
   * @description Checks if one U128 value is greater than another.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {Boolean} True if a is greater than b, false otherwise.
   */
  export pure circuit gtU128(a: U128, b: U128): Boolean {
    return a.high > b.high || (a.high == b.high && a.low > b.low);
  }

  /**
   * @title Greater Than or Equal U128 circuit
   * @description Checks if one U128 value is greater than or equal to another.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {Boolean} True if a is greater than or equal to b, false otherwise.
   */
  export pure circuit gteU128(a: U128, b: U128): Boolean {
    return gtU128(a, b) || eqU128(a, b);
  }

  /**
   * @title Add circuit
   * @description Adds two U128 values, returning a U256.
   *
   * Theoretical Description:
   * This circuit computes the sum of two 128-bit unsigned integers, a and b, both represented as
   * U128 structs ({ low: Uint<64>, high: Uint<64> }). The result is a U256 struct
   * ({ low: U128, high: U128 }) containing the sum, where result.low holds the lower 128 bits and
   * result.high holds any carry into the upper 128 bits. The addition handles carries from the low
   * and high 64-bit parts to ensure accurate 256-bit representation of the sum.
   *
   * Mathematical Steps:
   * 1. Handle Special Cases:
   *    - If A = 0 (using MathU128_isZero), return B as a U256 with high part {0, 0}.
   *    - Else if B = 0 (using MathU128_isZero), return A as a U256 with high part {0, 0}.
   *    - Else if A = 2^128 - 1 (a.low = a.high = MAX_U64) and B = 1 (b.low = 1, b.high = 0),
   *      return { low: {0, 0}, high: {1, 0} } (2^128).
   * 2. Low Part Addition:
   *    - Compute lowSumFull = a.low + b.low, where lowSumFull is in [0, 2^65 - 2].
   * 3. Low Part Decomposition:
   *    - Convert lowSumFull to U128: lowSumFullU128 = toU128(lowSumFull).
   *    - Extract carry = lowSumFullU128.high (0 or 1, bit 64).
   * 4. High Part Addition with Carry:
   *    - Compute highSumIntermediate = a.high + b.high, where highSumIntermediate is in [0, 2^65 - 2].
   *    - Compute highSumFull = highSumIntermediate + carry, where highSumFull is in [0, 2^65 - 1].
   *    - Convert highSumFull to U128: highSumFullU128 = toU128(highSumFull).
   *    - Extract carryHigh = highSumFullU128.high (0 or 1, bit 128).
   * 5. Result Construction:
   *    - Define result.low = { low: lowSumFullU128.low, high: highSumFullU128.low } (bits 0-127).
   *    - Define result.high = { low: carryHigh, high: 0 } (bit 128 and above).
   *    - Return U256 { low: result.low, high: result.high }.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} a - The first U128 value to add.
   * @param {U128} b - The second U128 value to add.
   *
   * @returns {U256} The sum of a and b as a U256 struct, with low (bits 0-127) and high (bits 128-255) parts.
   */
  circuit _add(a: U128, b: U128): U256 {
    if (isZeroU128(a)) {
       // Special case: a = 0, return b
       return U256 { low: b, high: ZERO_U128() };
    }
    else
       if (isZeroU128(b)) {
          // Special case: b = 0, return a
          return U256 { low: a, high: ZERO_U128() };
       }
       else {
          // General case
          const lowSumFull = a.low + b.low;
          const lowSumFullU128 = toU128(lowSumFull);
          const carry = lowSumFullU128.high;
          const highSumIntermediate = a.high + b.high;
          const highSumFull = highSumIntermediate + carry;
          const highSumFullU128 = toU128(highSumFull);
          const carryHigh = highSumFullU128.high;

          return U256 { low: U128 { low: lowSumFullU128.low, high: highSumFullU128.low },
                        high: U128 { low: carryHigh, high: 0 } };
       }
  }

  /**
   * @title Add circuit
   * @description Adds two Uint<128> values.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {U256} The sum of a and b.
   */
  export circuit add(a: Uint<128>, b: Uint<128>): U256 {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    return _add(aU128, bU128);
  }

  /**
   * @title Add U128 circuit
   * @description Adds two U128 values.
   * 
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `U128` structs.
   * - Result is returned as `U256` to handle potential overflow.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {U256} The sum of a and b.
   */
  export circuit addU128(a: U128, b: U128): U256 {
    return _add(a, b);
  }

  /**
   * @title Add Checked circuit
   * @description Adds two Uint<128> values with overflow checking.
   *
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `Uint<128>` values.
   * - Result must not overflow 128 bits.
   *
   * @circuitInfo k=10, rows=575
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @throws {Error} "MathU128: addition overflow" if the result would overflow 128 bits.
   *
   * @returns {Uint<128>} The sum of a and b.
   */
  export circuit addChecked(a: Uint<128>, b: Uint<128>): Uint<128> {
    return (a + b) as Uint<128>;
  }

  /**
   * @title Add Checked U128 circuit
   * @description Adds two U128 values with overflow checking.
   *
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `U128` structs.
   * - Result must not overflow 128 bits.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @throws {Error} "MathU128: addition overflow" if the result would overflow 128 bits.
   *
   * @returns {Uint<128>} The sum of a and b.
   */
  export circuit addCheckedU128(a: U128, b: U128): Uint<128> {
    return (fromU128(a) + fromU128(b)) as Uint<128>;
  }

  /**
   * @title Subtract circuit
   * @description Subtracts one Uint<128> value from another.
   *
   * @remarks
   * Requirements:
   * - `a` must be greater than or equal to `b` to prevent underflow.
   * - Both inputs must be valid `Uint<128>` values.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {Uint<128>} a - The Uint<128> value to subtract from (minuend).
   * @param {Uint<128>} b - The Uint<128> value to subtract (subtrahend).
   *
   * @returns {Uint<128>} The difference between a and b.
   *
   * @throws {Error} "MathU128: subtraction underflow" If a < b.
   */
  export pure circuit sub(a: Uint<128>, b: Uint<128>): Uint<128> {
    assert(a >= b, "MathU128: subtraction underflow");
    return a - b;
  }

  /**
   * @title Subtract U128 circuit
   * @description Subtracts one U128 value from another.
   *
   * Theoretical Description:
   * This circuit computes the difference between two 128-bit unsigned integers, a and b, both
   * represented as U128 structs ({ low: Uint<64>, high: Uint<64> }). The result is a U128 struct
   * representing a - b. It checks for underflow to ensure a >= b, throwing an error if the result
   * would be negative.
   *
   * Mathematical Steps:
   * 1. Handle Special Cases:
   *    - If B = 0 (using MathU128_isZero), return A (A - 0 = A).
   *    - Else if A = B (using MathU128_eqU128), return { low: 0, high: 0 } (A - A = 0).
   *    - Else if A = 2^128 - 1 (a.low = a.high = MAX_U64) and B = 1 (b.low = 1, b.high = 0),
   *      return { low: MAX_U64 - 1, high: MAX_U64 } (2^128 - 2).
   * 2. Underflow Verification:
   *    - Assert A >= B using _gt or _eq (i.e., not A < B).
   *    - If A < B, throw "MathU128: subtraction underflow".
   * 3. Borrow Determination:
   *    - Compute borrow = 1 if a.low < b.low, else 0.
   * 4. High Part Subtraction:
   *    - Compute highWithBorrow = b.high + borrow, where highWithBorrow is in [0, 2^64].
   *    - Compute highDiff = a.high - highWithBorrow, where highDiff is in [0, 2^64 - 1].
   * 5. Low Part Subtraction:
   *    - If borrow = 0 (a.low >= b.low), compute lowDiff = a.low - b.low.
   *    - If borrow = 1 (a.low < b.low), compute lowDiff = a.low + 2^64 - b.low.
   * 6. Result Construction:
   *    - Return U128 { low: lowDiff, high: highDiff }.
   *
   * @circuitInfo k=10, rows=451
   *
   * @param {U128} a - The U128 value to subtract from (minuend).
   * @param {U128} b - The U128 value to subtract (subtrahend).
   *
   * @throws {Error} "MathU128: subtraction underflow" If a < b.
   *
   * @returns {U128} The difference a - b as a U128 struct.
   */
  export pure circuit subU128(a: U128, b: U128): U128 {
    if (isZeroU128(b)) {
       // Special case: b = 0, return a
       return a;
    } else
       if (eqU128(a, b)) {
          // Special case: a = b, return 0
          return ZERO_U128();
       } else {
          // General case
          assert(gtU128(a, b) || eqU128(a, b), "MathU128: subtraction underflow");

          const borrow = a.low < b.low ? 1 as Uint<64> : 0 as Uint<64>;
          const highWithBorrow = b.high + borrow;
          const highDiff = a.high - highWithBorrow;

          if (borrow == 0) {
             const lowDiff = a.low - b.low;
             return U128 { low: lowDiff, high: highDiff };
          } else {
             const lowDiff = a.low + MODULUS() - b.low;
             return U128 { low: lowDiff as Uint<64>, high: highDiff };
          }
       }
  }

  /**
   * @title Multiply circuit
   * @description Multiplies two U128 values, returning the full 256-bit result.
   *
   * Theoretical Description:
   * This circuit computes the product of two 128-bit unsigned integers, a and b, both represented as
   * U128 structs ({ low: Uint<64>, high: Uint<64> }). The result is a U256 struct
   * ({ low: U128, high: U128 }) containing the full 256-bit product, where result.low holds bits 0-127
   * and result.high holds bits 128-255. The multiplication uses a schoolbook method with partial products
   * and carry propagation, optimized with special cases for common inputs.
   *
   * Mathematical Steps:
   * 1. Handle Special Cases:
   *    - If A = 0 or B = 0 (using MathU128_isZero), return ZERO_U256 (A * 0 = 0).
   *    - Else if A = 1 (a.low = 1, a.high = 0), return B as a U256 with high part {0, 0} (1 * B = B).
   *    - Else if B = 1 (b.low = 1, b.high = 0), return A as a U256 with high part {0, 0} (A * 1 = A).
   *    - Else if A = 2^128 - 1 (a.low = a.high = MAX_U64) and B = 2 (b.low = 2, b.high = 0),
   *      return { low: {MAX_U64 - 1, MAX_U64}, high: {1, 0} } (2^129 - 2).
   * 2. Partial Product Computation:
   *    - Compute four partial products as 128-bit integers:
   *      ll = a.low * b.low (bits 0-127)
   *      hl = a.high * b.low (bits 64-191)
   *      lh = a.low * b.high (bits 64-191)
   *      hh = a.high * b.high (bits 128-255)
   * 3. Partial Product Conversion:
   *    - Convert each to U128: llU128, hlU128, lhU128, hhU128.
   * 4. Middle Term Summation:
   *    - Compute crossSum = hlU128 + lhU128 using _add, resulting in a U256 covering bits 64-319.
   * 5. Low Part Alignment and Addition:
   *    - Define crossShifted = { low: 0, high: crossSum.low.low } (bits 64-127).
   *    - Compute lowAndCross = llU128 + crossShifted using _add, covering bits 0-255.
   * 6. Carry Propagation:
   *    - Define crossCarry = { low: crossSum.low.high, high: crossSum.high.low } (bits 128-255).
   *    - Compute highPartU256 = hhU128 + crossCarry using _add, covering bits 128-383.
   * 7. High Part Combination:
   *    - Compute finalHigh = lowAndCross.high + highPartU256.low using _add, covering bits 128-255.
   * 8. Result Construction:
   *    - Return U256 { low: lowAndCross.low, high: finalHigh.low }.
   *
   * @circuitInfo k=11, rows=1750
   *
   * @param {U128} a - The first U128 value to multiply.
   * @param {U128} b - The second U128 value to multiply.
   *
   * @returns {U256} The product a * b as a U256 struct.
   */
  circuit _mul(a: U128, b: U128): U256 {
    if (isZeroU128(a) || isZeroU128(b)) {
       // Special case: a = 0 or b = 0, return 0
       return U256 { low: U128 { low: 0, high: 0 }, high: U128 { low: 0, high: 0 } };
    }
    else
       if (eqU128(a, U128 { low: 1, high: 0 })) {
          // Special case: a = 1, return b
          return U256 { low: b, high: U128 { low: 0, high: 0 } };
       }
       else
          if (eqU128(b, U128 { low: 1, high: 0 })) {
             // Special case: b = 1, return a
             return U256 { low: a, high: U128 { low: 0, high: 0 } };
          }
          else {
             // Compute partial products (each is Uint<128>)
             const ll = a.low * b.low; // Bits 0-127
             const hl = a.high * b.low; // Bits 64-191
             const lh = a.low * b.high; // Bits 64-191
             const hh = a.high * b.high; // Bits 128-255

             // Convert partial products to U128 structs
             const llU128 = toU128(ll);
             const hlU128 = toU128(hl);
             const lhU128 = toU128(lh);
             const hhU128 = toU128(hh);

             // Combine hl and lh (bits 64-191) using _add, which returns a U256
             const crossSum = _add(hlU128, lhU128); // U256 { low: bits 64-191, high: bits 192-319 }

             // Extract bits 64-127 (crossSum.low.low) for crossShifted
             const crossShifted = U128 { low: 0 as Uint<64>, high: crossSum.low.low }; // Bits 64-127

             // Add crossShifted to ll to get bits 0-127 of the final result
             const lowAndCross = _add(llU128, crossShifted); // U256 { low: bits 0-127, high: bits 128-255 }

             // Extract the carry from crossSum (bits 128-191 are in crossSum.low.high, bits 192-255 in crossSum.high.low)
             const crossCarry = U128 { low: crossSum.low.high, high: crossSum.high.low }; // Bits 128-191, 192-255

             // Add crossCarry to hh to form the high part (bits 128-255)
             const highPartU256 = _add(hhU128, crossCarry); // U256 { low: bits 128-255, high: bits 256-383 }

             // Construct the final U256 result
             // lowAndCross.low contains bits 0-127
             // lowAndCross.high contains bits 128-255 (first part of the high bits)
             // highPartU256.low contains bits 128-255 (second part, needs to be combined)
             // highPartU256.high contains bits 256-383 (should be 0, as the product fits in 256 bits)
             const finalLow = lowAndCross.low; // Bits 0-127
             const finalHigh = _add(lowAndCross.high, highPartU256.low); // Combine bits 128-255

             return U256 { low: finalLow, // Bits 0-127
                           high: finalHigh.low // Bits 128-255
                           };
          }
  }

  /**
   * @title Multiply Checked U128 circuit
   * @description Internal implementation of checked multiplication for U128 values.
   *
   * @circuitInfo k=11, rows=1752
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @throws {Error} "MathU128: multiplication overflow" If the result would overflow 128 bits.
   *
   * @returns {U128} The product of a and b.
   */
  circuit _mulChecked(a: U128, b: U128): U128 {
    const result = _mul(a, b);
    assert(eqU128(result.high, ZERO_U128()), "MathU128: multiplication overflow");
    return result.low;
  }

  /**
   * @title Multiply circuit
   * @description Multiplies two Uint<128> values.
   *
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `Uint<128>` values.
   * - Result is returned as `U256` to handle full product.
   *
   * @circuitInfo k=11, rows=1874
   *
   * @param {Uint<128>} a - The first Uint<128> value to multiply.
   * @param {Uint<128>} b - The second Uint<128> value to multiply.
   *
   * @returns {U256} The full product of a and b.
   */
  export circuit mul(a: Uint<128>, b: Uint<128>): U256 {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    return _mul(aU128, bU128);
  }

  /**
   * @title Multiply U128 circuit
   * @description Multiplies two U128 values.
   *
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `U128` structs.
   * - Result is returned as `U256` to handle full product.
   *
   * @circuitInfo k=11, rows=1750
   *
   * @param {U128} a - The first U128 value to multiply.
   * @param {U128} b - The second U128 value to multiply.
   *
   * @returns {U256} The full product of a and b.
   */
  export circuit mulU128(a: U128, b: U128): U256 {
    return _mul(a, b);
  }

  /**
   * @title Multiply Checked circuit
   * @description Multiplies two Uint<128> values with overflow checking.
   *
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `Uint<128>` values.
   * - Result must not overflow 128 bits.
   *
   * @circuitInfo k=11, rows=1876
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @throws {Error} "MathU128: multiplication overflow" if the result would overflow 128 bits.
   *
   * @returns {Uint<128>} The product of a and b.
   */
  export circuit mulChecked(a: Uint<128>, b: Uint<128>): Uint<128> {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    return (fromU128(_mulChecked(aU128, bU128)) as Uint<128>);
  }

  /**
   * @title Multiply Checked U128 circuit
   * @description Multiplies two U128 values with overflow checking.
   *
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `U128` structs.
   * - Result must not overflow 128 bits.
   *
   * @circuitInfo k=11, rows=1752
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @throws {Error} "MathU128: multiplication overflow" if the result would overflow 128 bits.
   *
   * @returns {Uint<128>} The product of a and b.
   */
  export circuit mulCheckedU128(a: U128, b: U128): Uint<128> {
    return (fromU128(_mulChecked(a, b)) as Uint<128>);
  }

  /**
  * @description Divides a U128 value by another, returning quotient and remainder.
  *
  * Theoretical Description:
  * This circuit computes the quotient and remainder of dividing a 128-bit unsigned integer a by
  * another b, both represented as U128 structs ({ low: Uint<64>, high: Uint<64> }). It returns a
  * DivResultU128 struct containing the quotient and remainder, satisfying a = quotient * b + remainder,
  * where 0 <= remainder < b.
  *
  * Mathematical Steps:
  * 1. Handle Special Cases:
  *    - If B = 0 (using MathU128_isZero), throw "MathU128: division by zero".
  *    - Else if A = 0 (using MathU128_isZero), return { quotient: ZERO_U128, remainder: ZERO_U128 }.
  *    - Else if B = 1 (b.low = 1, b.high = 0), return { quotient: A, remainder: ZERO_U128 }.
  *    - Else if A = B (using MathU128_eqU128), return { quotient: {low: 1, high: 0}, remainder: ZERO_U128 }.
  *    - Else if A < B (using MathU128__le), return { quotient: ZERO_U128, remainder: A }.
  * 2. Division Computation:
  *    - Compute a_uint128 = a.high * 2^64 + a.low and b_uint128 = b.high * 2^64 + b.low using fromU128.
  *    - Compute result = (quotient, remainder) using divU128Locally, where quotient = floor(a_uint128 / b_uint128)
  *      and remainder = a_uint128 mod b_uint128.
  * 3. Remainder Verification:
  *    - Assert remainder <= b using _le, ensuring remainder < b.
  * 4. Correctness Verification:
  *    - Compute productU256 = quotient * b using _mul.
  *    - Compute lowSumU256 = productU256.low + remainderU256 using _add.
  *    - Compute highSumU256 = productU256.high + lowSumU256.high using _add.
  *    - Assert highSumU256.low = highSumU256.high = 0 and lowSumU256.low = a.
  * 5. Result:
  *    - Return DivResultU128 { quotient, remainder }.
  *
  * @circuitInfo k=12, rows=2778
  *
  * @param {U128} a - The U128 value to divide (dividend).
  * @param {U128} b - The U128 value to divide by (divisor).
  *
  * @throws {Error} "MathU128: division by zero" If b is zero.
  * @throws {Error} "MathU128: remainder error" If remainder is not less than or equal to b.
  * @throws {Error} "MathU128: division invalid" If quotient * b + remainder does not equal a.
  *
  * @returns {DivResultU128} A struct containing the quotient and remainder as U128 values.
  */
  circuit _div(a: U128, b: U128): DivResultU128 {
    assert(!isZeroU128(b), "MathU128: division by zero");

    if (isZeroU128(a)) {
       // Special case: dividend is zero
       return DivResultU128 { quotient: ZERO_U128(), remainder: ZERO_U128() };
    }
    else
       if (eqU128(b, U128 { low: 1, high: 0 })) {
          // Special case: divisor is one
          return DivResultU128 { quotient: a, remainder: ZERO_U128() };
       }
       else
          if (eqU128(a, b)) {
             // Special case: dividend equals divisor
             return DivResultU128 { quotient: U128 { low: 1, high: 0 }, remainder: ZERO_U128() };
          }
          else
             if (lteU128(a, b)) {
                // Special case: dividend less than divisor
                return DivResultU128 { quotient: ZERO_U128(), remainder: a };
             }
             else {
                assert(!isZeroU128(b), "MathU128: division by zero");
                const result = divU128Locally(a, b);
                assert(ltU128(result.remainder, b), "MathU128: remainder error");

                // quotient * b + remainder == a
                // Compute sumU256 = productU256 + remainderU256
                const productU256 = _mul(result.quotient, b);
                const remainderU256 = U256 { low: result.remainder, high: ZERO_U128() };
                const lowSumU256 = _add(productU256.low, result.remainder);
                const highSumU256 = _add(productU256.high, lowSumU256.high); // Add carry to high part

                // Verify that sumU256.low == a and sumU256.high == 0
                assert((eqU128(highSumU256.low, ZERO_U128()) &&
                        eqU128(highSumU256.high, ZERO_U128()) &&
                        eqU128(lowSumU256.low, a)), "MathU128: division invalid");

                return result;
             }
  }

  /**
   * @title Division circuit
   * @description Divides a Uint<128> a by a Uint<128> b, returning the quotient.
   *
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=12, rows=2778
   *
   * @param {Uint<128>} a - The Uint<128> value to divide.
   * @param {Uint<128>} b - The Uint<128> value to divide by.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   * @throws {Error} "MathU128: remainder error" if remainder is not less than b.
   * @throws {Error} "MathU128: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {Uint<128>} The quotient of the division.
   */
  export circuit div(a: Uint<128>, b: Uint<128>): Uint<128> {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    return fromU128(_div(aU128, bU128).quotient);
  }

  /**
   * @title Division U128 circuit
   * @description Divides a U128 a by a U128 b, returning the quotient.
   *
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=12, rows=2641
   *
   * @param {U128} a - The U128 value to divide.
   * @param {U128} b - The U128 value to divide by.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   * @throws {Error} "MathU128: remainder error" if remainder is not less than b.
   * @throws {Error} "MathU128: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {U128} The quotient of the division.
   */
  export circuit divU128(a: U128, b: U128): U128 {
    return _div(a, b).quotient;
  }

  /**
   * @title Remainder circuit
   * @description Computes the remainder of dividing a Uint<128> a by a Uint<128> b.
   *
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=12, rows=2778
   *
   * @param {Uint<128>} a - The Uint<128> value to divide.
   * @param {Uint<128>} b - The Uint<128> value to divide by.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   * @throws {Error} "MathU128: remainder error" if remainder is not less than b.
   * @throws {Error} "MathU128: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {Uint<128>} The remainder of the division.
   */
  export circuit rem(a: Uint<128>, b: Uint<128>): Uint<128> {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    return fromU128(_div(aU128, bU128).remainder);
  }

  /**
   * @title Remainder U128 circuit
   * @description Computes the remainder of dividing a U128 a by a U128 b.
   *
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=12, rows=2778
   *
   * @param {U128} a - The U128 value to divide.
   * @param {U128} b - The U128 value to divide by.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   * @throws {Error} "MathU128: remainder error" if remainder is not less than b.
   * @throws {Error} "MathU128: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {U128} The remainder of the division.
   */
  export circuit remU128(a: U128, b: U128): U128 {
    return _div(a, b).remainder;
  }

  /**
   * @title Division with Remainder circuit
   * @description Divides a Uint<128> a by a Uint<128> b, returning quotient and remainder.
   *
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=12, rows=2819
   *
   * @param {Uint<128>} a - The Uint<128> value to divide.
   * @param {Uint<128>} b - The Uint<128> value to divide by.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   * @throws {Error} "MathU128: remainder error" if remainder is not less than b.
   * @throws {Error} "MathU128: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {DivResultU128} A struct containing the quotient and remainder.
   */
  export circuit divRem(a: Uint<128>, b: Uint<128>): DivResultU128 {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    return _div(aU128, bU128);
  }

  /**
   * @title Division with Remainder U128 circuit
   * @description Divides a U128 a by a U128 b, returning quotient and remainder.
   *
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=12, rows=2695
   *
   * @param {U128} a - The U128 value to divide.
   * @param {U128} b - The U128 value to divide by.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   * @throws {Error} "MathU128: remainder error" if remainder is not less than b.
   * @throws {Error} "MathU128: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {DivResultU128} A struct containing the quotient and remainder.
   */
  export circuit divRemU128(a: U128, b: U128): DivResultU128 {
    return _div(a, b);
  }

  /**
   * @title Floor Square Root U128 circuit
   * @description Computes the floor of the square root of a U128 value.
   *
   * Theoretical Description:
   * This circuit calculates the floor of the square root R = floor(sqrt(N)) of a 128-bit unsigned integer
   * N, represented as a U128 struct ({ low: Uint<64>, high: Uint<64> }). The result is a Uint<64> value
   * R in [0, 2^64 - 1], such that R^2 <= N < (R + 1)^2. It uses a witness-based approach for the general
   * case and includes special cases for common inputs to optimize performance.
   *
   * Mathematical Steps:
   * 1. Handle Special Cases:
   *    - If N = 0 (using MathU128_isZero), return 0.
   *    - Else if N = 1 (radicand.low = 1, radicand.high = 0), return 1.
   *    - Else if N = 2 (radicand.low = 2, radicand.high = 0), return 1.
   *    - Else if N = 3 (radicand.low = 3, radicand.high = 0), return 1.
   *    - Else if N = 4 (radicand.low = 4, radicand.high = 0), return 2.
   *    - Else if N = 9 (radicand.low = 9, radicand.high = 0), return 3.
   *    - Else if N = 2^8 - 1 = 255 (radicand.low = Max_U8, radicand.high = 0), return 15.
   *    - Else if N = 2^16 - 1 = 65535 (radicand.low = Max_U16, radicand.high = 0), return 255.
   *    - Else if N = 2^32 - 1 = 4294967295 (radicand.low = Max_U32, radicand.high = 0), return 65535.
   *    - Else if N = 2^64 - 1 (radicand.low = Max_U64, radicand.high = 0), return 4294967295.
   *    - Else if N = 1000000 (radicand.low = 1000000, radicand.high = 0), return 1000.
   *    - Else if N = 2^128 - 1 (radicand.low = radicand.high = Max_U64), return Max_U64.
   * 2. General Case Computation:
   *    - Compute N_uint128 = radicand.high * 2^64 + radicand.low using fromU128.
   *    - Compute R = floor(sqrt(N_uint128)) using sqrtU128Locally, where R is in [0, 2^64 - 1].
   * 3. Root Verification:
   *    - Define rootU128 = { low: R, high: 0 }.
   *    - Compute rootSquareU256 = rootU128 * rootU128 using _mul.
   *    - Assert rootSquareU256.high = {0, 0} (no overflow beyond 128 bits).
   *    - Assert rootSquareU256.low <= radicand using !_gt.
   * 4. Next Value Verification:
   *    - Compute next = R + 1, where next is in [1, 2^64].
   *    - Define nextU128 = { low: next, high: 0 }.
   *    - Compute nextSquareU256 = nextU128 * nextU128 using _mul.
   *    - Assert nextSquareU256.high = {0, 0} (no overflow beyond 128 bits).
   *    - Assert nextSquareU256.low > radicand using _gt.
   * 5. Result:
   *    - Return R as Uint<64>.
   *
   * @remarks
   * Requirements:
   * - `radicand` must be a valid U128 value.
   * - The result R must satisfy R^2 <= radicand < (R + 1)^2.
   *
   * @circuitInfo k=12, rows=2778
   *
   * @param {U128} radicand - The U128 value to compute the square root of.
   *
   * @throws {Error} "MathU128: sqrt root^2 overflow" If R^2 overflows 128 bits.
   * @throws {Error} "MathU128: sqrt overestimate" If R^2 > radicand.
   * @throws {Error} "MathU128: sqrt next overflow" If (R + 1)^2 overflows 128 bits.
   * @throws {Error} "MathU128: sqrt underestimate" If (R + 1)^2 <= radicand.
   *
   * @returns {Uint<64>} The floor of the square root of radicand.
   */
  circuit _sqrt(radicand: U128): Uint<64> {
    if (isZeroU128(radicand)) {
       return 0 as Uint<64>;
    } else
       if (eqU128(radicand, U128 { low: 1, high: 0 })) {
          return 1 as Uint<64>;
       } else
          if (eqU128(radicand, U128 { low: 2, high: 0 })) {
             return 1 as Uint<64>;
          }
          else
             if (eqU128(radicand, U128 { low: 3, high: 0 })) {
                return 1 as Uint<64>;
             }
             else
                if (eqU128(radicand, U128 { low: 4, high: 0 })) {
                   return 2 as Uint<64>;
                }
                else
                   if (eqU128(radicand, U128 { low: 9, high: 0 })) {
                      return 3 as Uint<64>;
                   }
                   else
                      if (eqU128(radicand, U128 { low: MAX_UINT8(), high: 0 })) {
                         return 15 as Uint<64>;
                      }
                      else
                         if (eqU128(radicand, U128 { low: MAX_UINT16(), high: 0 })) {
                            return 255 as Uint<64>;
                         }
                         else
                            if (eqU128(radicand, U128 { low: MAX_UINT32(), high: 0 })) {
                               return 65535 as Uint<64>;
                            }
                            else
                               if (eqU128(radicand, U128 { low: MAX_UINT64(), high: 0 })) {
                                  return 4294967295 as Uint<64>;
                               }
                               else
                                  if (eqU128(radicand, MAX_U128())) {
                                     return MAX_UINT64();
                                  }
                                  else {
                                     const root = sqrtU128Locally(radicand);
                                     const rootU128 = U128 { low: root, high: 0 };
                                     const rootSquareU256 = _mul(rootU128, rootU128); // U256 { low: U128, high: U128 }
                                     assert(eqU128(rootSquareU256.high, ZERO_U128()), "MathU128: sqrt root^2 overflow");

                                     const rootSquareU128 = rootSquareU256.low; // U128
                                     assert(!gtU128(rootSquareU128, radicand), "MathU128: sqrt overestimate");

                                     const next = root + 1 as Uint<64>;
                                     const nextU128 = U128 { low: next, high: 0 };
                                     const nextSquareU256 = _mul(nextU128, nextU128); // U256 { low: U128, high: U128 }
                                     assert(eqU128(nextSquareU256.high, ZERO_U128()), "MathU128: next sqrt overflow");

                                     const nextSquareU128 = nextSquareU256.low; // U128
                                     assert(gtU128(nextSquareU128, radicand), "MathU128: sqrt underestimate");
                                     return root;
                                  }
  }

  /**
   * @title Square Root circuit
   * @description Computes the square root of a Uint<128> value.
   *
   * @remarks
   * Requirements:
   * - `radicand` must be a valid `Uint<128>` value.
   * - Uses internal `_sqrt` circuit for computation.
   *
   * @circuitInfo k=12, rows=2778
   *
   * @param {Uint<128>} radicand - The Uint<128> value to compute the square root of.
   *
   * @throws {Error} "MathU128: sqrt root^2 overflow" if root^2 overflows.
   * @throws {Error} "MathU128: sqrt overestimate" if root^2 > radicand.
   * @throws {Error} "MathU128: sqrt next overflow" if (root + 1)^2 overflows.
   * @throws {Error} "MathU128: sqrt underestimate" if (root + 1)^2 <= radicand.
   *
   * @returns {Uint<64>} The floor of the square root of radicand.
   */
  export circuit sqrt(radicand: Uint<128>): Uint<64> {
    const radicandU128 = toU128(radicand);
    return _sqrt(radicandU128);
  }

  /**
   * @title Square Root U128 circuit
   * @description Computes the square root of a U128 value.
   *
   * @remarks
   * Requirements:
   * - `radicand` must be a valid `U128` struct.
   * - Uses internal `_sqrt` circuit for computation.
   *
   * @circuitInfo k=12, rows=2778
   *
   * @param {U128} radicand - The U128 value to compute the square root of.
   *
   * @throws {Error} "MathU128: sqrt root^2 overflow" if root^2 overflows.
   * @throws {Error} "MathU128: sqrt overestimate" if root^2 > radicand.
   * @throws {Error} "MathU128: sqrt next overflow" if (root + 1)^2 overflows.
   * @throws {Error} "MathU128: sqrt underestimate" if (root + 1)^2 <= radicand.
   *
   * @returns {Uint<64>} The floor of the square root of radicand.
   */
  export circuit sqrtU128(radicand: U128): Uint<64> {
    return _sqrt(radicand);
  }

  /**
   * @title Min circuit
   * @description Returns the minimum of two Uint<128> values.
   *
   * @circuitInfo k=12, rows=2759
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Uint<128>} The smaller of a and b.
   */
  export pure circuit min(a: Uint<128>, b: Uint<128>): Uint<128> {
    return lte(a, b) ? a : b;
  }

  /**
   * @title Min U128 circuit
   * @description Returns the minimum of two U128 values.
   *
   * @circuitInfo k=12, rows=2759
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {U128} The smaller of a and b.
   */
  export pure circuit minU128(a: U128, b: U128): U128 {
    return lteU128(a, b) ? a : b;
  }

  /**
   * @title Max circuit
   * @description Returns the maximum of two Uint<128> values.
   *
   * @circuitInfo k=12, rows=2759
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Uint<128>} The larger of a and b.
   */
  export pure circuit max(a: Uint<128>, b: Uint<128>): Uint<128> {
    return gte(a, b) ? a : b;
  }

  /**
   * @title Max U128 circuit
   * @description Returns the maximum of two U128 values.
   *
   * @circuitInfo k=12, rows=2759
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {U128} The larger of a and b.
   */
  export pure circuit maxU128(a: U128, b: U128): U128 {
    return gteU128(a, b) ? a : b;
  }

  /**
   * @title Is Multiple circuit
   * @description Checks if a U128 value is a multiple of another.
   *
   * This circuit determines whether a 128-bit unsigned integer (`a`) is a multiple of another
   * 128-bit unsigned integer (`b`), both represented as U128 structs
   * (`{ low: Uint<64>, high: Uint<64> }`). It returns a Boolean indicating whether `a` is divisible
   * by `b` with no remainder (i.e., `a mod b = 0`).
   *
   * Theoretical Description:
   * The circuit checks if a 128-bit unsigned integer a, represented as
   * a = a.high * 2^64 + a.low, is a multiple of another 128-bit unsigned integer b,
   * represented as b = b.high * 2^64 + b.low, where a.high, a.low, b.high, and b.low are in
   * [0, 2^64 - 1]. The result is true if there exists an integer k such that a = k * b,
   * equivalent to a mod b = 0, and false otherwise.
   *
   * Mathematical Steps:
   * 1. Division by Zero Check:
   *    - Verify that b != 0, i.e., b.high > 0 or b.low > 0.
   *    - If b = 0, terminate with an error indicating division by zero.
   * 2. Division Computation:
   *    - Compute the quotient and remainder of a divided by b:
   *      - Let result = (quotient, remainder) such that a = quotient * b + remainder,
   *        where quotient and remainder are 128-bit unsigned integers, and
   *        0 <= remainder < b.
   *      - Here, quotient = floor(a / b) and remainder = a mod b.
   * 3. Remainder Check:
   *    - Represent remainder as remainder = remainder.high * 2^64 + remainder.low, where
   *      remainder.high, remainder.low are in [0, 2^64 - 1].
   *    - Verify that remainder = 0, i.e., remainder.high = 0 and remainder.low = 0.
   * 4. Result:
   *    - Return true if remainder = 0, indicating a is a multiple of b (a mod b = 0).
   *    - Return false otherwise, indicating a is not a multiple of b.
   *
   * The circuit ensures correctness by computing the remainder of a divided by b and checking
   * if it is zero, using division and comparison operations, while preventing division by zero.

   * @circuitInfo k=12, rows=2759
   *
   * @param {U128} a - The U128 value to check.
   * @param {U128} b - The U128 value to test against.
   *
   * @returns {Boolean} True if a is a multiple of b, false otherwise.
   */
  circuit _isMultiple(a: U128, b: U128): Boolean {
    assert(b.high > 0 || b.low > 0, "MathU128: division by zero");
    const result = _div(a, b);
    return eqU128(result.remainder, ZERO_U128());
  }

  /**
   * @title Is Multiple circuit
   * @description Checks if a Uint<128> value is a multiple of another.
   *
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_isMultiple` circuit for computation.
   *
   * @circuitInfo k=12, rows=2759
   *
   * @param {Uint<128>} a - The Uint<128> value to check.
   * @param {Uint<128>} b - The Uint<128> b to test against.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   *
   * @returns {Boolean} True if value is a multiple of b, false otherwise.
   */
  export circuit isMultiple(a: Uint<128>, b: Uint<128>): Boolean {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    return _isMultiple(aU128, bU128);
  }

  /**
   * @title Is Multiple U128 circuit
   * @description Checks if a U128 value is a multiple of another.
   *
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_isMultiple` circuit for computation.
   *
   * @circuitInfo k=12, rows=2635
   *
   * @param {U128} a - The U128 value to check.
   * @param {U128} b - The U128 b to test against.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   *
   * @returns {Boolean} True if value is a multiple of b, false otherwise.
   */
  export circuit isMultipleU128(a: U128, b: U128): Boolean {
    return _isMultiple(a, b);
  }
}
